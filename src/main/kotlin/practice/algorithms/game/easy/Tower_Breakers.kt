package practice.algorithms.game.easy

fun main(args: Array<String>) {
    val t = readLine()!!.trim().toInt()

    for (tItr in 1..t) {
        val nm = readLine()!!.split(" ")
        val n = nm[0].trim().toInt()
        val m = nm[1].trim().toInt()
        // 方法1
        // 这个游戏没有玩过，所以玩一下
        // 赢的条件是让对手无路可走，那么这个条件就是谁先将(n)
        // 砍到1，谁就赢了，那么我们先看看：
        // 1个柱子：
        //    高度如果是1那么P1输。如果是2-X，那么P1稳赢，因为
        //    P1可始终减少X-1导致剩下的高度只有1，那么P2就输了
        // 2个柱子：
        //    高度如果是1那么P1输。如果是2-X，那么P1也稳输，
        //    因为无论P1怎样移动一个柱子，P2可以采用相同的策略
        //    移动另外一个柱子，这样导致P1必然先将一个柱子移动
        //    到无法移动，也即是高度为1，而P2随之将另外一个柱子
        //    移动到高度为1，这样P1再无移动空间
        // 3个柱子：
        //    高度如果是1那么P1输。如果是2-X，那么P1稳赢，因为
        //    P1可以先移动一个柱子到无法移动，而P2无论怎么样移动
        //    另外两个柱子，都会先移动完其中一个柱子，这样剩下的
        //    那个柱子就只能让P1移动完了。
        // 那么玩几局就可以看出来了，
        // 如果柱子(n)是奇数且高度(m)大于1的话，那么先手稳赢
        // 否则就稳输
        // AC
        println(if (n % 2 == 1 && m > 1) 1 else 2)
    }
}